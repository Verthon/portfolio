---
title: Deno 2 quick overview
published: true
description: 'Quick overview of the Deno 2 and its mission to uncomplicate JavaScript'
tags: testing
date: 2024-11-02
excerpt: Deno is a modern JavaScript runtime. Deno claims to be secure by default, with native support for TypeScript and JSX. Backward compatible with Node.js.
article_type: featured
---

import ArticleWrapper from '~/blog/components/article-wrapper/article-wrapper'
import ArticleHeader from '~/blog/components/article-header/article-header'
import ArticleContent from '~/blog/components/article-content/article-content'
import Heading from '~/common/components/heading/heading'
import Alert from '~/common/components/alert/alert'

<ArticleWrapper>
<ArticleHeader>
<Heading tag='h1'>Deno 2 quick overview</Heading>
</ArticleHeader>

<ArticleContent>
<Heading tag='h2' id='javascript-runtimes'>JavaScript runtimes</Heading>

Deno is a JavaScript runtime, built on [V8](https://v8.dev/), [Rust](https://www.rust-lang.org/) and [Tokio](https://tokio.rs/). Released in 2018, it just hit a major milestone with the release of Deno 2.0 in October 2024.

<Heading tag="h2" id="core-design-principles">Core design principles</Heading>

- Zero config TypeScript support 
- [ECMA Script
modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)
only 
- complete toolchain with included: 
- test runner 
- standard library
- linter and formatter 
- built-in HTTP server 
- support for Web API's (fetch,crypto, web sockets, workers and [many more](https://docs.deno.com/api/web/)) 
- requires explicit permission for: 
  - network access 
  - file access 
  - environment access 
- JSR registry like npm but for ESM only 
- Node.js backward compatibility layer

<Heading tag="h2" id="getting-started">Getting started</Heading>

The easiest way to install Deno is to either use: 
- Shell `curl -fsSL https://deno.land/install.sh | sh` 
- Or homebrew `brew install deno`

For more methods and OS please refer to [official docs](https://docs.deno.com/runtime/getting_started/installation/)

Create a Deno project
`deno init deno_test`

It will create the project with a simple TypeScript example and a test.

<Heading tag="h3" id="vscode-setup">VSCode setup</Heading>

To support Deno in VSCode you need to install [official plugin](https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno)
Make sure you provide the Deno path to the extension `which deno` and copy it to `deno.path`
You can autogenerate settings with `cmd + shift + p` or `ctrl + shift + p` and select `Deno initialize Workspace configuration`
Above step will create `.vscode/settings.json` with base setup for Deno for you.

<Heading tag="h3" id="deno-config-file">Deno config file</Heading>

Deno init created Deno config file `deno.json` with the following contents

```json
{
  "tasks": {
    "dev": "deno run --watch main.ts"
  },
  "imports": {
    "@std/assert": "jsr:@std/assert@1"
  }
}
```

- `tasks` act as `scripts` field in the Node.js package.json
- `imports` is similar to `dependencies` - it will contain your JSR and NPM packages

Additionally, you can configure other things like:
* `lint` - config will apply to built-in linter
* `fmt` - config will apply to build-in formatter
* `compilerOptions` - config for TypeScript
* `unstable` - toggle to enable unstable Deno features

**Note**: Deno provides JSON schema for autocomplete in the config file:
  https://deno.land/x/deno@v2.0.3/cli/schemas/config-file.v1.json?source

We can now run the tests:
`deno test`

<Heading tag="h2" id="jsr">JSR</Heading>

JSR is Deno's version of npm - aiming to not replace the npm but to be it's superset.
You can use it with any JavaScript package manager (pnpm, yarn, npm).

<Heading tag="h3">Example</Heading>

Let's try to install `valibot` package from the JSR in our demo project:
* run `deno add jsr:@valibot/valibot`
* new entry will be added to `deno.json` and `deno.lock`
* import it like in regular project `import {email, minLength, object, pipe, string} from "@valibot/valibot";`
Everything works the same way as in the regular Node project:
```ts
const LoginSchema = object({
	email: pipe(string(), email()),
	password: pipe(string(), minLength(8)),
});
```

<Heading tag="h3">Developer Experience Advantages</Heading>

Provides great DX for package authors with:
* auto-generating the `d.ts` and docs
* enforcing the semver
* no need for the bundling process, just export your entry TS file
* publishing package via CLI `deno publish` or link to Github repository

Provides great DX for package users:
* has scoring system to determine package health, [example of Hono framework score](https://jsr.io/@hono/hono/score)
* provides automatic commands of how to use it with popular package managers and runtimes
* basic docs - autogenerated from the source-code
* source code overview (you don't have to visit Github to check source code)
* JSR packages can be used in any JS project that has `node_modules`

To demonstrate last point I will install the Deno standard library `collections` module in regular Node.js project:
- We need to install the collections module `pnpm dlx jsr add @std/collections`
- Import it like a regular npm package:

```ts
import { maxBy } from "@std/collections";
const t = maxBy(
		[
			{ name: "Anna", age: 34 },
			{ name: "Kim", age: 42 },
			{ name: "John", age: 23 },
		],
		(person) => person.age
	)
```

<Heading tag="h3">Tradeoffs</Heading>

* Sadly there are many packages still missing in JSR (total 7184) - hopefully it will change over time <span role="img">ðŸ¤ž</span>
* JSR has strict policies for TypeScript, ESM and package score - it won't help with adoption for other packages
* JSR Search [Orama](https://orama.com/) based search has significant usability issues, as highlighted by the lack of relevant results and incomplete or deprecated packages appearing in searches. [original issue](https://github.com/jsr-io/jsr/issues/311)


<Heading tag="h2" id="standard-library">
  Standard library
</Heading>
Sadly, unlike other programming languages, JavaScript still lacks a standard library. Deno Team and its community seem to be filling in this missing part.
STD is available on the [JSR](https://jsr.io/@std) with the following advantages:
- written in TypeScript
- no external dependencies
- reviewed by the Deno Core Team Members
- designed to work in any JavaScript environment
- fully-tree-shakeable

Even if the code is on the JSR you can import some modules to the regular JS project, for example:
1. `pnpm dlx jsr add @std/encoding`
2. `import * as _std_encoding from "@std/encoding";`

<Heading tag="h2" id="summary">
  Summary
</Heading>

Deno will be an ideal "starter" for any JS code challenges like the advent of code. Deno's zero-config setup really shines here.  
CLI tools and automation scripts may also really benefit from the Deno security model.  
I don't expect Deno to gain more popularity in the upcoming years.

<Heading tag="h3" id="advantages">Advantages</Heading>
1. Built in cross-platform binary creation
2. Security model for files, environment access and network
3. Complete toolchain, no need for installing linters, formatters, bundlers etc.
4. Out of the box TypeScript support ([Node is working on it too](https://nodejs.org/en/learn/typescript/run-natively))
5. Support for Web API's
6. LTS versions

<Heading tag="h3" id="tradeoffs">Tradeoffs</Heading>
1. Limited ecosystem compared to the npm registry
2. Many Node packages still need testing with the compatibility layer
3. Deno's funding, primarily from venture capital sources
4. Way smaller community
5. No Deno SQL Lite API <span role="img">ðŸ˜‰</span> ([Node already has it as an experimental](https://nodejs.org/docs/latest/api/sqlite.html))

</ArticleContent>

</ArticleWrapper>
